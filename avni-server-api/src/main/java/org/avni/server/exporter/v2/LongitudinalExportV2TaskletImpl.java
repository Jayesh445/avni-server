package org.avni.server.exporter.v2;

import org.avni.server.exporter.LongitudinalExportTasklet;
import org.avni.server.service.ExportS3Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.item.ExecutionContext;
import org.springframework.batch.item.file.FlatFileItemWriter;
import org.springframework.batch.item.file.transform.DelimitedLineAggregator;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.core.io.FileSystemResource;

import javax.persistence.EntityManager;
import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Stream;

public class LongitudinalExportV2TaskletImpl implements LongitudinalExportTasklet {

    private static final Logger logger = LoggerFactory.getLogger(LongitudinalExportV2TaskletImpl.class);
    private final int cacheClearSize;
    private final EntityManager entityManager;
    private final ExportV2CSVFieldExtractor exportV2CSVFieldExtractor;
    private final ExportV2Processor exportV2Processor;
    private final ExportS3Service exportS3Service;
    private final String jobUuid;
    private final Iterator iterator;
    private final Stream stream;

    private int read;
    private FlatFileItemWriter<LongitudinalExportItemRow> writer;


    public LongitudinalExportV2TaskletImpl(int cacheClearSize, EntityManager entityManager, ExportV2CSVFieldExtractor exportV2CSVFieldExtractor,
                                           ExportV2Processor exportV2Processor, ExportS3Service exportS3Service, String jobUuid, Stream stream) {
        this.cacheClearSize = cacheClearSize;
        this.entityManager = entityManager;
        this.exportV2CSVFieldExtractor = exportV2CSVFieldExtractor;
        this.exportV2Processor = exportV2Processor;
        this.exportS3Service = exportS3Service;
        this.jobUuid = jobUuid;
        this.stream = stream;
        this.exportV2Processor.setExportOutput(exportV2CSVFieldExtractor.getExportOutput());
        iterator = stream.iterator();
    }

    @Override
    public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {
        createFileWriter(jobUuid, chunkContext.getStepContext().getStepExecution().getExecutionContext());
        List<LongitudinalExportItemRow> itemRows = new ArrayList<>();
        while (true) {
            if (!iterator.hasNext()) {
                logger.info("All records processed, writing last set to file");
                writeToFile(itemRows);
                break;
            }
            read++;
            Object individual = iterator.next();
            LongitudinalExportItemRow itemRow = exportV2Processor.process(individual);
            itemRows.add(itemRow);

            if (cacheClearSize == read) {
                logger.info(String.format("Read %d records which is equal to cache clear size of %d. Clearing entity manager", read, cacheClearSize));
                writeToFile(itemRows);
                itemRows.clear();
                entityManager.flush();
                entityManager.clear();
                read = 0;
            }
        }

        logger.info("Completed reading all records");
        return RepeatStatus.FINISHED;
    }

    private void createFileWriter(String uuid, ExecutionContext executionContext) {
        writer = new FlatFileItemWriter<>();
        File outputFile = exportS3Service.getLocalExportFile(uuid);
        writer.setResource(new FileSystemResource(outputFile));
        DelimitedLineAggregator<LongitudinalExportItemRow> delimitedLineAggregator = new DelimitedLineAggregator<>();
        delimitedLineAggregator.setDelimiter(",");
        delimitedLineAggregator.setFieldExtractor(exportV2CSVFieldExtractor);
        writer.setLineAggregator(delimitedLineAggregator);
        writer.setHeaderCallback(exportV2CSVFieldExtractor);
        writer.open(executionContext);
        logger.info(String.format("Writing to file:%s", outputFile.getAbsolutePath()));
    }

    private void writeToFile(List<LongitudinalExportItemRow> rows) throws Exception {
        if (rows.isEmpty()) return;
        writer.write(rows);
    }

    @Override
    public void clean() {
        logger.info("Closing the result set stream");
        try {
            writer.close();
        } catch (Exception e) {
            logger.error("Error closing writer", e);
        }

        try {
            stream.close();
        } catch (Exception e) {
            logger.error("Error closing data stream", e);
        }
    }
}
